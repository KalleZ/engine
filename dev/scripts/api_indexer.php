<?php
	/**
	 * Tuxxedo Software Engine
	 * =============================================================================
	 *
	 * @author		Kalle Sommer Nielsen 	<kalle@tuxxedo.net>
	 * @author		Ross Masters 		<ross@tuxxedo.net>
	 * @version		1.0
	 * @copyright		Tuxxedo Software Development 2006+
	 * @license		Apache License, Version 2.0
	 * @package		Engine
	 * @subpackage		Dev
	 *
	 * =============================================================================
	 */


	/**
	 * Aliasing rules
	 */
	use DevTools\Utilities\IO;
	use Tuxxedo\Version;


	/**
	 * Bootstraper
	 */
	require(__DIR__ . '/includes/bootstrap.php');



	/**
	 * Template cache for templates
	 *
	 * @author		Kalle Sommer Nielsen <kalle@tuxxedo.net>
	 * @version		1.0
	 * @package		Engine
	 * @subpackage		Dev
	 */
	abstract class TemplateCache
	{
		/**
		 * Holds the loaded templates
		 *
		 * @var		array
		 */
		protected static $templates		= Array();
	}

	/**
	 * Template class
	 *
	 * @author		Kalle Sommer Nielsen <kalle@tuxxedo.net>
	 * @version		1.0
	 * @package		Engine
	 * @subpackage		Dev
	 */
	class Template extends TemplateCache
	{
		/**
		 * Name of the template currently loaded
		 *
		 * @var		string
		 */
		protected $name;

		/**
		 * Template variables
		 *
		 * @var		array
		 */
		protected $variables			= Array();


		/**
		 * Loads a new template and constructs the object
		 *
		 * Invalid templates halts the execution of the script.
		 *
		 * @param	string			The name of the template
		 */
		public function __construct($template)
		{
			$template = strtolower($template);

			if(!isset(TemplateCache::$templates[$template]))
			{
				if(!is_file('./apidump/templates/' . $template . '.raw'))
				{
					IO::text('Error: Template file does not exists (' . $template . '.raw)');
					exit;
				}

				TemplateCache::$templates[$template] = file_get_contents('./apidump/templates/' . $template . '.raw');
			}

			$this->name 			= $template;
			$this->variables['version']	= Version::FULL;
		}

		/**
		 * Property overloader, to register template variables
		 *
		 * @param	string			The name of the variable
		 * @param	string			The value of the variable
		 * @return	void			No value is returned
		 */
		public function __set($variable, $value)
		{
			$this->variables[strtolower((string) $variable)] = (string) $value;
		}

		/**
		 * Property overloader, to get template variables
		 *
		 * @param	string			The name of the variable
		 * @return	void			Returns the value of the variable
		 */
		public function __get($variable)
		{
			$variable = strtolower((string) $variable);

			if(isset($this->variables[$variable]))
			{
				return($this->variables[$variable]);
			}
		}

		/**
		 * String conversation overloader
		 *
		 * @return	string			 Returns the parsed template
		 */
		public function __toString()
		{
			return((string) $this->parse());
		}

		/**
		 * Parses the template variables
		 *
		 * @return	string			 Returns the parsed template
		 */
		public function parse()
		{
			$cache = TemplateCache::$templates[$this->name];

			if($this->variables)
			{
				foreach($this->variables as $variable => $value)
				{
					$cache = str_replace('{$' . $variable . '}', $value, $cache);
				}
			}

			return($cache);
		}

		/**
		 * Saves the contents to a file
		 *
		 * @param	string			Name of the file (will be: './apidump/output/XXX.html')
		 * @return	boolean			Returns true if the file was saved with success, otherwise false
		 */
		public function save($file)
		{
			return(file_put_contents('./apidump/output/' . $file . '.html', $this->parse()));
		}
	}

	/**
	 * Layout class
	 *
	 * Layout wrapper class around the base template, see the 
	 * constructor for more information.
	 *
	 * @author		Kalle Sommer Nielsen <kalle@tuxxedo.net>
	 * @version		1.0
	 * @package		Engine
	 * @subpackage		Dev
	 */
	class Layout extends Template
	{
		/**
		 * Loads a new template in layout mode
		 *
		 * This causes the template cache to be invoked and loads in 'header' and 'footer' 
		 * which then will be declared as variables.
		 *
		 * @param	string			The name of the template
		 */
		public function __construct($template)
		{
			parent::__construct($template);

			$this->variables['header']	= (string) new Template('header');
			$this->variables['footer']	= (string) new Template('footer');
		}
	}

	/**
	 * Hash registry
	 *
	 * This class is a local cache for the hashes generated by the 
	 * api_file_hash() function. It will attempt to load the 'api_hashes.json' 
	 * file if it exists in the output directory.
	 *
	 * @author		Kalle Sommer Nielsen <kalle@tuxxedo.net>
	 * @version		1.0
	 * @package		Engine
	 * @subpackage		Dev
	 */
	class HashRegistry
	{
		/**
		 * Stored hashes
		 *
		 * @var		\stdClass
		 */
		protected $hashes;


		/**
		 * Constructor, this will attempt to see if the file 'api_hashes.json' 
		 * exists within the output directory, and load it.
		 */
		public function __construct()
		{
			if(is_file('./apidump/output/api_hashes.json') && ($json = json_decode(file_get_contents('./apidump/output/api_hashes.json'))) !== false)
			{
				$this->hashes = $json;
			}
			else
			{
				$this->hashes = new stdClass;
			}
		}

		/**
		 * Destructor, saves the hashes to the 'api_hashes.json' file if possible
		 */
		public function __destruct()
		{
			if($this->hashes)
			{
				file_put_contents('./apidump/output/api_hashes.json', json_encode($this->hashes));
			}
		}

		/**
		 * Gets a hash (or generates a new one)
		 *
		 * @param	string				The type ('constant', 'function', 'class' or 'interface')
		 * @param	string				The name of the object (fx. for function: 'api_file_hash')
		 * @param	string				The file of where the object exists (fx. 'library/Tuxxedo/Bootstrap.php'), this is case sensitive
		 * @return	string				Returns a file name without an extension (fx. 'constant-tuxxedo-library-123456') or false on failure
		 */
		public function hash($type, $name, $file)
		{
			static $types;

			if(!$types)
			{
				$types	= Array('constant', 'function', 'class', 'interface');
			}

			$type = strtolower($type);
			$name = strtolower($name);

			if(!in_array($type, $types))
			{
				return(false);
			}

			if(!isset($this->hashes->{$type}))
			{
				$this->hashes->{$type} = new stdClass;
			}

			if(!isset($this->hashes->{$type}->{$file}))
			{
				$this->hashes->{$type}->{$file} = new stdClass;
			}

			if(!isset($this->hashes->{$type}->{$file}->{$name}))
			{
				$this->hashes->{$type}->{$file}->{$name} = api_file_hash($type, $name);
			}

			return($this->hashes->{$type}->{$file}->{$name});
		}
	}


	/**
	 * File hash
	 *
	 * Generates a file hash (filename) based on the name and type to 
	 * avoid possible naming conflicts.
	 *
	 * @param	string				The type ('constant', 'function', 'class' or 'interface')
	 * @param	string				The name of the object (fx. for function: 'api_file_hash')
	 * @return	string				Returns a file name without an extension (fx. 'constant-tuxxedo-library-123456') or false on failure
	 */
	function api_file_hash($type, $name)
	{
		static $rng, $lcache, $types;

		if(!$rng)
		{
			$lcache	= Array();
			$types	= Array('constant', 'function', 'class', 'interface');
			$rng 	= function()
			{
				return(str_pad(mt_rand(0, 999999), 6, 0, STR_PAD_LEFT));
			};
		}

		$type = strtolower($type);

		if(!in_array($type, $types))
		{
			return(false);
		}

		do
		{
			$n = $rng();

			if(!isset($lcache[$n]))
			{
				$lcache[$n] = Array(
							$type, 
							$name
							);
			}
		}
		while(!isset($lcache[$n]));

		if($name{0} == '\\')
		{
			$name = substr($name, 1);
		}

		return($type . '-' . str_replace(Array('_', '.', '\\'), '-', strtolower($name)) . '-' . $n);
	}


	IO::signature();
	IO::headline('API Indexer', 1);

	$cli	= IO::isCli();
	$json 	= json_decode(file_get_contents('./apidump/engine_api.json'));

	if(!$json)
	{
		IO::text('Error: Unable to read Engine API from the exported JSON file');
		exit;
	}

	IO::ul();
	IO::li('Reading API dump...');

	$hashreg	= new HashRegistry;
	$constants 	= $functions = $classes = $interfaces = Array();

	foreach($json as $file => $struct)
	{
		if($struct->functions)
		{
			foreach($struct->functions as $meta)
			{
				$functions[] = array_merge(Array('file' => $file, 'hash' => $hashreg->hash('function', $meta->function, $file)), (array) $meta);
			}
		}

		if($struct->constants)
		{
			foreach($struct->constants as $name => $meta)
			{
				$constants[] = array_merge(Array('name' => $name, 'file' => $file, 'hash' => $hashreg->hash('constant', $name, $file)), (array) $meta);
			}
		}

		foreach(Array('classes' => 'class', 'interfaces' => 'interface') as $type => $types)
		{
			if(!$struct->{$type})
			{
				continue;
			}

			foreach($struct->{$type} as $name => $meta)
			{
				${$type}[] = array_merge(Array('name' => $name, 'file' => $file, 'hash' => $hashreg->hash($types, $name, $file)), (array) $meta);
			}
		}
	}

	$generated_tocs = Array();
	$obj_types	= Array('constants', 'functions', 'classes', 'interfaces');

	foreach($obj_types as $obj)
	{
		if(!sizeof(${$obj}))
		{
			continue;
		}

		$generated_tocs[] = $obj;
	}

	if(!$generated_tocs)
	{
		IO::ul(IO::TAG_END);

		IO::text('Error: No generatable elements found for table of contents');
		exit;
	}

	$docblock = function(Array $meta, $tag)
	{
		if(strtolower($tag) == 'tags' || !isset($meta['docblock']) || !isset($meta['docblock']->{$tag}))
		{
			return('Undefined value');
		}

		return($meta['docblock']->{$tag});
	};

	$docblock_tag = function(Array $meta, $tag)
	{
		if(!isset($meta['docblock']) || !isset($meta['docblock']->tags) || !isset($meta['docblock']->tags->{$tag}))
		{
			return('Undefined value');
		}

		return($meta['docblock']->tags->{$tag});
	};

	$prototype = function($name, Array $meta)
	{
		$return = 'void';
		$params = '';

		if($meta['docblock'] && isset($meta['docblock']->tags))
		{
			if(isset($meta['docblock']->tags->param))
			{
				foreach($meta['docblock']->tags->param as $param)
				{
					$params .= $param[0] . ', ';
				}

				$params = rtrim($params, ', ');
			}

			if(isset($meta['docblock']->tags->return))
			{
				$return = $meta['docblock']->tags->return[0];
			}
		}

		if(!empty($meta['namespace']))
		{
			$name = $meta['namespace'] . '\\' . $name;
		}

		return(sprintf('%s%s(%s)', $return, $name, $params));
	};

	$nl2br = function($string)
	{
		return(str_replace("\n\n", '<br />', str_replace(Array("\n\r", "\r\n", "\r"), "\n", $string)));
	};

	$mformat = function($name, $as)
	{
		if($as == 'properties')
		{
			return('$' . $name);
		}

		if($as == 'methods')
		{
			return($name . '()');
		}

		return($name);
	};

	IO::li('Generating API pages...');

	$mtypes = Array(
			'constants'	=> 'constant', 
			'properties'	=> 'property', 
			'methods'	=> 'method'
			);

	foreach($generated_tocs as $type)
	{
		IO::ul();
		IO::li(ucfirst($type));
		IO::ul();

		${$type . '_ptr'} 	= Array();
		$ptr 			= &${$type . '_ptr'};

		foreach(${$type} as $gtype => $meta)
		{
			${$type . '_ptr'}[$gtype] = (isset($meta['function']) ? $meta['function'] : $meta['name']);
		}

		asort(${$type . '_ptr'});

		switch($type)
		{
			case('constants'):
			{
				foreach($ptr as $const => $name)
				{
					$meta 			= $constants[$const];

					$template 		= new Layout('api_constant');
					$template->name		= $name;
					$template->file		= $meta['file'];
					$template->datatype	= $docblock_tag($meta, 'var');
					$template->namespace	= (empty($meta['namespace']) ? 'Global namespace' : $meta['namespace']);
					$template->description	= (($desc = $docblock($meta, 'description')) !== '' ? $nl2br($desc) : 'No description available');

					$template->save($meta['hash']);

					IO::li($name);
				}
			}
			break;
			case('functions'):
			{
				foreach($ptr as $function => $name)
				{
					$meta 			= $functions[$function];
					$parameters		= $returns = '';

					if(($p = $docblock_tag($meta, 'param')) !== 'Undefined value')
					{
						$pl		= '';
						$parameters 	= new Template('parameters');

						foreach($p as $pa)
						{
							$pt 			= new Template('parameter');
							$pt->datatype 		= $pa[0];
							$pt->description	= $pa[1];

							$pl 			.= $pt;
						}

						$parameters->parameter_list = $pl;
					}

					if(($p = $docblock_tag($meta, 'return')) !== 'Undefined value')
					{
						$returns	= new Template('returns');
						$returns->value	= $p[1];
					}

					$template		= new Layout('api_function');
					$template->name		= $name . '()';
					$template->file		= $meta['file'];
					$template->prototype	= $prototype($name, $meta);
					$template->namespace	= (empty($meta['namespace']) ? 'Global namespace' : $meta['namespace']);
					$template->description	= (($desc = $docblock($meta, 'description')) !== '' ? $nl2br($desc) : 'No description available');
					$template->parameters	= $parameters;
					$template->returns	= $returns;

					$template->save($meta['hash']);

					IO::li($name);
				}
			}
			break;
			case('classes'):
			case('interfaces'):
			{
/* @todo Generate constant files */
/* @todo Generate property files */
/* @todo Generate method files */
/* @todo Generate a synopsis */
/* @todo Display visibility in the meta information box */
/* @todo Display parent class/interface in the meta information box */
/* @todo Display the implemented interfaces in the meta information box */
				$rtype = ($type == 'classes' ? 'class' : 'interface');

				foreach($ptr as $obj_id => $name)
				{
					$meta 		= ${$type}[$obj_id];
					$contents 	= '';

					foreach(Array('constants', 'properties', 'methods') as $mtype)
					{
						if(!$meta[$mtype])
						{
							continue;
						}

						$content 	= '';
						$mptr 		= Array();

						foreach($meta[$mtype] as $m_id => $mmeta)
						{
							$mptr[$mmeta->{$mtypes[$mtype]}] = $m_id;
						}

						ksort($mptr);

						foreach($mptr as $m_name => $m_id)
						{
							$tmeta			= $meta[$mtype][$m_id];

							$template 		= new Template('obj_contents_bit');
							$template->name		= $mformat($m_name, $mtype);
							$template->link		= '';
							$template->description	= (($desc = $docblock((array) $tmeta, 'description')) !== '' ? substr($desc, 0, 100) . (strlen($desc) > 100 ? '...' : '') : 'No description available');;

							$content		.= $template;
						}

						$template 		= new Template('obj_contents');
						$template->type		= ucfirst($mtypes[$mtype]);
						$template->mtype	= ucfirst($mtype);
						$template->content	= $content;

						$contents		.= $template;
					}

					if(empty($contents))
					{
						$contents = 'None';
					}

					$template		= new Layout('api_object');
					$template->name		= $name;
					$template->type		= ucfirst($rtype);
					$template->mtype	= $type;
					$template->file		= $meta['file'];
					$template->namespace	= (empty($meta['namespace']) ? 'Global namespace' : $meta['namespace']);
					$template->description	= (($desc = $docblock($meta, 'description')) !== '' ? $nl2br($desc) : 'No description available');
					$template->contents 	= $contents;

					$template->save($meta['hash']);

					IO::li($name);
				}
			}
			break;
			default:
			{
				IO::text('Error: Unable to handle unknown type: ' . $type);
				exit;
			}
			break;
		}

		IO::ul(IO::TAG_END);
		IO::ul(IO::TAG_END);
	}

	foreach($generated_tocs as $obj)
	{
		$bits		= '';
		$toc		= new Layout('toc');
		$toc->name	= ucfirst($obj);
		$toc->seealso	= new Template('toc_seealso');

		foreach(${$obj . '_ptr'} as $key => $name)
		{
			$data 			= ${$obj}[$key];
			$name			= (is_scalar($data) ? $data : (is_array($data) && isset($data['name']) ? $data['name'] : $data['function']));

			$bit 			= new Template('toc_bit');
			$bit->link		= $data['hash'] . '.html';
			$bit->name		= $name;
			$bit->description	= (isset($data['docblock']) && isset($data['docblock']->description) ? substr($data['docblock']->description, 0, 100) . (strlen($data['docblock']->description) > 100 ? '...' : '') : 'No description available');

			$bits 			.= (string) $bit;
		}

		$toc->toc = $bits;

		$toc->save($obj);
	}

	IO::li('Generating table of contents');
	IO::ul();

	$descriptions	= Array(
				'constants'	=> 'Global constants', 
				'functions'	=> 'Procedural functions', 
				'classes'	=> 'Class synopsises', 
				'interfaces'	=> 'Interface structures'
				);

	$bits		= '';
	$toc 		= new Layout('toc');
	$toc->name	= 'Table of contents';
	$toc->seealso	= '';

	foreach($generated_tocs as $gtoc)
	{
		$bit 			= new Template('toc_bit');
		$bit->link		= $gtoc . '.html';
		$bit->name		= ucfirst($gtoc);
		$bit->description	= $descriptions[$gtoc];

		$bits			.= (string) $bit;

		IO::li($bit->name);
	}

	$toc->toc = $bits;

	$toc->save('index');

	IO::ul(IO::TAG_END);
	IO::ul(IO::TAG_END);
?>