<?php
	/**
	 * Tuxxedo Software Engine
	 * =============================================================================
	 *
	 * @author		Kalle Sommer Nielsen 	<kalle@tuxxedo.net>
	 * @author		Ross Masters 		<ross@tuxxedo.net>
	 * @version		1.0
	 * @copyright		Tuxxedo Software Development 2006+
	 * @license		Apache License, Version 2.0
	 * @package		Engine
	 * @subpackage		Dev
	 *
	 * =============================================================================
	 */


	/**
	 * Aliasing rules
	 */
	use DevTools\Utilities\IO;
	use Tuxxedo\Version;


	/**
	 * Bootstraper
	 */
	require(__DIR__ . '/includes/bootstrap.php');



	/**
	 * Template cache for templates
	 *
	 * @author		Kalle Sommer Nielsen <kalle@tuxxedo.net>
	 * @version		1.0
	 * @package		Engine
	 * @subpackage		Dev
	 */
	abstract class TemplateCache
	{
		/**
		 * Holds the loaded templates
		 *
		 * @var		array
		 */
		protected static $templates		= Array();
	}

	/**
	 * Template class
	 *
	 * @author		Kalle Sommer Nielsen <kalle@tuxxedo.net>
	 * @version		1.0
	 * @package		Engine
	 * @subpackage		Dev
	 */
	class Template extends TemplateCache
	{
		/**
		 * Name of the template currently loaded
		 *
		 * @var		string
		 */
		protected $name;

		/**
		 * Template variables
		 *
		 * @var		array
		 */
		protected $variables			= Array();


		/**
		 * Loads a new template and constructs the object
		 *
		 * Invalid templates halts the execution of the script.
		 *
		 * @param	string			The name of the template
		 */
		public function __construct($template)
		{
			$template = strtolower($template);

			if(!isset(TemplateCache::$templates[$template]))
			{
				if(!is_file('./apidump/templates/' . $template . '.raw'))
				{
					IO::text('Error: Template file does not exists (' . $template . '.raw)');
					exit;
				}

				TemplateCache::$templates[$template] = file_get_contents('./apidump/templates/' . $template . '.raw');
			}

			$this->name 			= $template;
			$this->variables['version']	= Version::FULL;
		}

		/**
		 * Property overloader, to register template variables
		 *
		 * @param	string			The name of the variable
		 * @param	string			The value of the variable
		 * @return	void			No value is returned
		 */
		public function __set($variable, $value)
		{
			$this->variables[strtolower((string) $variable)] = (string) $value;
		}

		/**
		 * Property overloader, to get template variables
		 *
		 * @param	string			The name of the variable
		 * @return	void			Returns the value of the variable
		 */
		public function __get($variable)
		{
			$variable = strtolower((string) $variable);

			if(isset($this->variables[$variable]))
			{
				return($this->variables[$variable]);
			}
		}

		/**
		 * String conversation overloader
		 *
		 * @return	string			 Returns the parsed template
		 */
		public function __toString()
		{
			return((string) $this->parse());
		}

		/**
		 * Parses the template variables
		 *
		 * @return	string			 Returns the parsed template
		 */
		public function parse()
		{
			$cache = TemplateCache::$templates[$this->name];

			if($this->variables)
			{
				foreach($this->variables as $variable => $value)
				{
					$cache = str_replace('{$' . $variable . '}', $value, $cache);
				}
			}

			return($cache);
		}

		/**
		 * Saves the contents to a file
		 *
		 * @param	string			Name of the file (will be: './apidump/output/XXX.html')
		 * @return	boolean			Returns true if the file was saved with success, otherwise false
		 */
		public function save($file)
		{
			return(file_put_contents('./apidump/output/' . $file . '.html', $this->parse()));
		}
	}

	/**
	 * Layout class
	 *
	 * Layout wrapper class around the base template, see the 
	 * constructor for more information.
	 *
	 * @author		Kalle Sommer Nielsen <kalle@tuxxedo.net>
	 * @version		1.0
	 * @package		Engine
	 * @subpackage		Dev
	 */
	class Layout extends Template
	{
		/**
		 * Loads a new template in layout mode
		 *
		 * This causes the template cache to be invoked and loads in 'header' and 'footer' 
		 * which then will be declared as variables.
		 *
		 * @param	string			The name of the template
		 */
		public function __construct($template)
		{
			parent::__construct($template);

			$this->variables['header']	= (string) new Template('header');
			$this->variables['footer']	= (string) new Template('footer');
		}
	}

	/**
	 * Hash registry
	 *
	 * This class is a local cache for the hashes generated by the 
	 * api_file_hash() function. It will attempt to load the 'api_hashes.json' 
	 * file if it exists in the output directory.
	 *
	 * @author		Kalle Sommer Nielsen <kalle@tuxxedo.net>
	 * @version		1.0
	 * @package		Engine
	 * @subpackage		Dev
	 */
	class HashRegistry
	{
		/**
		 * Stored hashes
		 *
		 * @var		\stdClass
		 */
		protected $hashes;


		/**
		 * Constructor, this will attempt to see if the file 'api_hashes.json' 
		 * exists within the output directory, and load it.
		 */
		public function __construct()
		{
			if(is_file('./apidump/output/api_hashes.json') && ($json = json_decode(file_get_contents('./apidump/output/api_hashes.json'))) !== false)
			{
				$this->hashes = $json;
			}
			else
			{
				$this->hashes = new stdClass;
			}
		}

		/**
		 * Destructor, saves the hashes to the 'api_hashes.json' file if possible
		 */
		public function __destruct()
		{
			if($this->hashes)
			{
				file_put_contents('./apidump/output/api_hashes.json', json_encode($this->hashes));
			}
		}

		/**
		 * Gets a hash (or generates a new one)
		 *
		 * @param	string				The type ('constant', 'function', 'class', 'interface', 'property' or 'method')
		 * @param	string				The name of the object (fx. for function: 'api_file_hash')
		 * @param	string				The file of where the object exists (fx. 'library/Tuxxedo/Bootstrap.php'), this is case sensitive
		 * @return	string				Returns a file name without an extension (fx. 'constant-tuxxedo-library-123456') or false on failure
		 */
		public function hash($type, $name, $file)
		{
			static $types;

			if(!$types)
			{
				$types	= Array('constant', 'function', 'class', 'interface', 'property', 'method');
			}

			$type = strtolower($type);
			$name = strtolower($name);

			if(!in_array($type, $types))
			{
				return(false);
			}

			if(!isset($this->hashes->{$type}))
			{
				$this->hashes->{$type} = new stdClass;
			}

			if(!isset($this->hashes->{$type}->{$file}))
			{
				$this->hashes->{$type}->{$file} = new stdClass;
			}

			if(!isset($this->hashes->{$type}->{$file}->{$name}))
			{
				$this->hashes->{$type}->{$file}->{$name} = api_file_hash($type, $name);
			}

			return($this->hashes->{$type}->{$file}->{$name});
		}
	}


	/**
	 * File hash
	 *
	 * Generates a file hash (filename) based on the name and type to 
	 * avoid possible naming conflicts.
	 *
	 * @param	string				The type ('constant', 'function', 'class', 'interface', 'property' or 'method')
	 * @param	string				The name of the object (fx. for function: 'api_file_hash')
	 * @return	string				Returns a file name without an extension (fx. 'constant-tuxxedo-library-123456') or false on failure
	 */
	function api_file_hash($type, $name)
	{
		static $rng, $lcache, $types;

		if(!$rng)
		{
			$lcache	= Array();
			$types	= Array('constant', 'function', 'class', 'interface', 'property', 'method');
			$rng 	= function()
			{
				return(str_pad(mt_rand(0, 999999), 6, 0, STR_PAD_LEFT));
			};
		}

		$type = strtolower($type);

		if(!in_array($type, $types))
		{
			return(false);
		}

		do
		{
			$n = $rng();

			if(!isset($lcache[$n]))
			{
				$lcache[$n] = Array(
							$type, 
							$name
							);
			}
		}
		while(!isset($lcache[$n]));

		if($name{0} == '\\')
		{
			$name = substr($name, 1);
		}

		return($type . '-' . str_replace(Array('_', '.', '\\'), '-', strtolower($name)) . '-' . $n);
	}


	IO::signature();
	IO::headline('API Indexer', 1);

	$cli	= IO::isCli();
	$json 	= json_decode(file_get_contents('./apidump/engine_api.json'));

	if(!$json)
	{
		IO::text('Error: Unable to read Engine API from the exported JSON file');
		exit;
	}

	IO::ul();
	IO::li('Reading API dump...');

	$hashreg	= new HashRegistry;
	$constants 	= $functions = $classes = $interfaces = Array();

	foreach($json as $file => $struct)
	{
		if($struct->functions)
		{
			foreach($struct->functions as $meta)
			{
				$functions[] = array_merge(Array('file' => $file, 'hash' => $hashreg->hash('function', $meta->function, $file)), (array) $meta);
			}
		}

		if($struct->constants)
		{
			foreach($struct->constants as $name => $meta)
			{
				$constants[] = array_merge(Array('name' => $name, 'file' => $file, 'hash' => $hashreg->hash('constant', $name, $file)), (array) $meta);
			}
		}

		foreach(Array('classes' => 'class', 'interfaces' => 'interface') as $type => $types)
		{
			if(!$struct->{$type})
			{
				continue;
			}

			foreach($struct->{$type} as $name => $meta)
			{
				${$type}[] = array_merge(Array('name' => $name, 'file' => $file, 'hash' => $hashreg->hash($types, $name, $file)), (array) $meta);
			}
		}
	}

	$generated_tocs = Array();
	$obj_types	= Array('constants', 'functions', 'classes', 'interfaces');

	foreach($obj_types as $obj)
	{
		if(!sizeof(${$obj}))
		{
			continue;
		}

		$generated_tocs[] = $obj;
	}

	if(!$generated_tocs)
	{
		IO::ul(IO::TAG_END);

		IO::text('Error: No generatable elements found for table of contents');
		exit;
	}

	$docblock = function(Array $meta, $tag, $strip_html = true)
	{
		$tag = strtolower($tag);

		if($tag == 'tags' || !isset($meta['docblock']) || !isset($meta['docblock']->{$tag}))
		{
			return('Undefined value');
		}
		elseif($tag == 'descriptions' && $strip_html)
		{
			return(strip_tags($meta['docblock']->{$tag}));
		}

		return($meta['docblock']->{$tag});
	};

	$docblock_tag = function(Array $meta, $tag)
	{
		if(!isset($meta['docblock']) || !isset($meta['docblock']->tags) || !isset($meta['docblock']->tags->{$tag}))
		{
			return('Undefined value');
		}

		return($meta['docblock']->tags->{$tag});
	};

	$prototype = function($name, Array $meta, $prefix = '')
	{
		$return = 'void';
		$params = '';

		if($meta['docblock'] && isset($meta['docblock']->tags))
		{
			if(isset($meta['docblock']->tags->param))
			{
				foreach($meta['docblock']->tags->param as $param)
				{
					$params .= $param[0] . ', ';
				}

				$params = rtrim($params, ', ');
			}

			if(isset($meta['docblock']->tags->return))
			{
				$return = $meta['docblock']->tags->return[0];
			}
		}

		if(!empty($meta['namespace']))
		{
			$name = $meta['namespace'] . '\\' . $name;
		}

		if(!empty($prefix))
		{
			$prefix = $prefix . '::';
		}

		return(sprintf('%s %s%s(%s)', $return, $prefix, $name, $params));
	};

	$nl2br = function($string)
	{
		return(str_replace("\n\n", '<br />', str_replace(Array("\n\r", "\r\n", "\r"), "\n", $string)));
	};

	$mformat = function($name, $as)
	{
		if($as == 'properties')
		{
			return('$' . $name);
		}

		if($as == 'methods')
		{
			return($name . '()');
		}

		return($name);
	};

	$desc = function(Array $meta, $strip_html = false) use($docblock)
	{
		$desc = $docblock($meta, 'description', $strip_html);

		if(empty($desc))
		{
			return('No description available');
		}

		return($desc);
	};

	$desct = function(Array $meta, $strip_html = false) use($desc)
	{
		$d = $desc($meta, $strip_html);

		if(strlen($d) > 100)
		{
			return(substr($d, 0, 100) . '...');
		}

		return($d);
	};

	IO::li('Generating API pages...');

	$mtypes = Array(
			'constants'	=> Array(
							'constant', 
							'api_obj_constant'
							), 
			'properties'	=> Array(
							'property', 
							'api_property'
							), 
			'methods'	=> Array(
							'method', 
							'api_method'
							)
			);

	foreach($generated_tocs as $type)
	{
		IO::ul();
		IO::li(ucfirst($type));
		IO::ul();

		${$type . '_ptr'} 	= Array();
		$ptr 			= &${$type . '_ptr'};

		foreach(${$type} as $gtype => $meta)
		{
			${$type . '_ptr'}[$gtype] = (isset($meta['function']) ? $meta['function'] : $meta['name']);
		}

		asort(${$type . '_ptr'});

		switch($type)
		{
			case('constants'):
			{
				foreach($ptr as $const => $name)
				{
					$meta 			= $constants[$const];

					$template 		= new Layout('api_constant');
					$template->name		= $name;
					$template->file		= $meta['file'];
					$template->datatype	= $docblock_tag($meta, 'var');
					$template->namespace	= (empty($meta['namespace']) ? 'Global namespace' : $meta['namespace']);
					$template->description	= $desc($meta);

					$template->save($meta['hash']);

					IO::li($name);
				}
			}
			break;
			case('functions'):
			{
				foreach($ptr as $function => $name)
				{
					$meta 			= $functions[$function];
					$parameters		= $returns = '';

					if(($p = $docblock_tag($meta, 'param')) !== 'Undefined value')
					{
						$pl		= '';
						$parameters 	= new Template('parameters');

						foreach($p as $pa)
						{
							$pt 			= new Template('parameter');
							$pt->datatype 		= htmlspecialchars($pa[0], ENT_QUOTES);
							$pt->description	= htmlspecialchars($pa[1], ENT_QUOTES);

							$pl 			.= $pt;
						}

						$parameters->parameter_list = $pl;
					}

					if(($p = $docblock_tag($meta, 'return')) !== 'Undefined value')
					{
						$returns	= new Template('returns');
						$returns->value	= $p[1];
					}

					$template		= new Layout('api_function');
					$template->name		= $name . '()';
					$template->file		= $meta['file'];
					$template->prototype	= $prototype($name, $meta);
					$template->namespace	= (empty($meta['namespace']) ? 'Global namespace' : $meta['namespace']);
					$template->description	= $desc($meta);
					$template->parameters	= $parameters;
					$template->returns	= $returns;

					$template->save($meta['hash']);

					IO::li($name);
				}
			}
			break;
			case('classes'):
			case('interfaces'):
			{
				$rtype = ($type == 'classes' ? 'class' : 'interface');

				foreach($ptr as $obj_id => $name)
				{
					IO::li($name);

					$meta 		= ${$type}[$obj_id];
					$contents 	= $extendedinfo = '';

					foreach(Array('constants', 'properties', 'methods') as $mtype)
					{
						if(!$meta[$mtype])
						{
							continue;
						}

						$content 	= '';
						$mptr 		= Array();

						foreach($meta[$mtype] as $m_id => $mmeta)
						{
							$mptr[$mmeta->{$mtypes[$mtype][0]}] = $m_id;
						}

						ksort($mptr);

						IO::li(ucfirst($mtype) . ':');
						IO::ul();

						foreach($mptr as $m_name => $m_id)
						{
							$tmeta			= &$meta[$mtype][$m_id];
							$tmeta->hash		= $hashreg->hash($mtypes[$mtype][0], $m_name, $meta['file']);

							$template 		= new Template('obj_contents_bit');
							$template->name		= $mformat($m_name, $mtype);
							$template->link		= $tmeta->hash . '.html';
							$template->description	= $desct((array) $tmeta);

							$content		.= $template;

							$template		= new Layout($mtypes[$mtype][1]);
							$template->name		= $mformat($m_name, $mtype);
							$template->file		= $meta['file'];
							$template->namespace	= (empty($meta['namespace']) ? 'Global namespace' : $meta['namespace']);
							$template->description	= $desc((array) $tmeta);
							$template->obj		= $meta['name'];
							$template->obj_link	= $meta['hash'] . '.html';
							$template->obj_type	= $type;

							if(($mtype == 'properties' || $mtype == 'methods'))
							{
								$counter 	= 0;
								$extendedinfo	= '';

								foreach(Array('abstract', 'final', 'static', 'protected', 'private', 'public') as $flag)
								{
									if(!isset($tmeta->metadata->{$flag}) || !$tmeta->metadata->{$flag})
									{
										continue;
									}

									$mtemplate 		= new Template((!$counter ? 'obj_element' : 'obj_element_bit'));
									$mtemplate->value	= $flag;

									if(!$counter++)
									{
										$mtemplate->element = 'Flags';
									}

									$extendedinfo .= $mtemplate;
								}

								$template->extendedinfo = $extendedinfo;
							}

							switch($mtype)
							{
								case('constants'):
								case('properties'):
								{
									$template->datatype = $docblock_tag((array) $tmeta, 'var');
								}
								break;
								case('methods'):
								{
									$parameters = $returns = '';

									if(($p = $docblock_tag((array) $tmeta, 'param')) !== 'Undefined value')
									{
										$pl		= '';
										$parameters 	= new Template('parameters');

										foreach($p as $pa)
										{
											$pt 			= new Template('parameter');
											$pt->datatype 		= htmlspecialchars($pa[0], ENT_QUOTES);
											$pt->description	= htmlspecialchars($pa[1], ENT_QUOTES);

											$pl 			.= $pt;
										}

										$parameters->parameter_list = $pl;
									}

									if(($p = $docblock_tag((array) $tmeta, 'return')) !== 'Undefined value')
									{
										$returns	= new Template('returns');
										$returns->value	= $p[1];
									}

									$template->prototype	= $prototype($m_name, (array) $tmeta, $name);
									$template->parameters 	= $parameters;
									$template->returns	= $returns;
								}
								break;
							}

							$template->save($tmeta->hash);

							IO::li($m_name);
						}

						IO::ul(IO::TAG_END);

						$template 		= new Template('obj_contents');
						$template->type		= ucfirst($mtypes[$mtype][0]);
						$template->mtype	= ucfirst($mtype);
						$template->content	= $content;

						$contents		.= $template;
					}

					if($meta['metadata']->abstract || $meta['metadata']->final)
					{
						$counter = 0;

						foreach(Array('abstract', 'final') as $flag)
						{
							if(!$meta['metadata']->{$flag})
							{
								continue;
							}

							$template 		= new Template((!$counter ? 'obj_element' : 'obj_element_bit'));
							$template->value	= $flag;

							if(!$counter++)
							{
								$template->element = 'Flags';
							}

							$extendedinfo .= $template;
						}
					}

					if($meta['extends'])
					{
						$template 		= new Template('obj_element');
						$template->element	= 'Extends';
						$template->value	= $meta['extends'];

						$extendedinfo		.= $template;
					}

					if($meta['implements'])
					{
						asort($meta['implements']);

						$counter = 0;

						foreach($meta['implements'] as $iface)
						{
							$template 		= new Template((!$counter ? 'obj_element' : 'obj_element_bit'));
							$template->value	= $iface;

							if(!$counter++)
							{
								$template->element = 'Implements';
							}

							$extendedinfo .= $template;
						}
					}

					if(empty($contents))
					{
						$contents = 'None';
					}

					if(strpos($name, '\\') !== false)
					{
						$name = explode('\\', $name);
						$name = end($name);
					}

					$template		= new Layout('api_object');
					$template->name		= $name;
					$template->type		= ucfirst($rtype);
					$template->mtype	= $type;
					$template->file		= $meta['file'];
					$template->namespace	= (empty($meta['namespace']) ? 'Global namespace' : $meta['namespace']);
					$template->description	= $nl2br($desc($meta));
					$template->contents 	= $contents;
					$template->extendedinfo	= $extendedinfo;

					$template->save($meta['hash']);
				}
			}
			break;
			default:
			{
				IO::text('Error: Unable to handle unknown type: ' . $type);
				exit;
			}
			break;
		}

		IO::ul(IO::TAG_END);
		IO::ul(IO::TAG_END);
	}

	foreach($generated_tocs as $obj)
	{
		$bits		= '';
		$toc		= new Layout('toc');
		$toc->name	= ucfirst($obj);
		$toc->seealso	= new Template('toc_seealso');

		foreach(${$obj . '_ptr'} as $key => $name)
		{
			$data 			= ${$obj}[$key];
			$name			= (is_scalar($data) ? $data : (is_array($data) && isset($data['name']) ? $data['name'] : $data['function']));

			$bit 			= new Template('toc_bit');
			$bit->link		= $data['hash'] . '.html';
			$bit->name		= $name;
			$bit->description	= $desct($data, true);

			$bits 			.= $bit;
		}

		$toc->toc = $bits;

		$toc->save($obj);
	}

	IO::li('Generating table of contents');
	IO::ul();

	$descriptions	= Array(
				'constants'	=> 'Global constants', 
				'functions'	=> 'Procedural functions', 
				'classes'	=> 'Class synopsises', 
				'interfaces'	=> 'Interface structures'
				);

	$bits		= '';
	$toc 		= new Layout('toc');
	$toc->name	= 'Table of contents';
	$toc->seealso	= '';

	foreach($generated_tocs as $gtoc)
	{
		$bit 			= new Template('toc_bit');
		$bit->link		= $gtoc . '.html';
		$bit->name		= ucfirst($gtoc);
		$bit->description	= $descriptions[$gtoc];

		$bits			.= $bit;

		IO::li($bit->name);
	}

	$toc->toc = $bits;

	$toc->save('index');

	IO::ul(IO::TAG_END);
	IO::ul(IO::TAG_END);
?>